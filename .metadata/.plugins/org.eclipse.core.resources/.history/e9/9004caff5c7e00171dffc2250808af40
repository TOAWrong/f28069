//
// filename 	: delta_trip_proc.c 
// projectname 	: 60kw Inverter for Jang Bogo Submarine
// 					PCB...  regen_dsp_110513, regen_sen_110513
// data			; start 110625 ~		
//					by cheoung soon gil  
// 
#include	<header.h>
#include	<extern.h>


// 매 PWM에서 확인한다. 
void trip_recording(int trip_code,double trip_data,char * st)
{
	if(gRunFlag)	gTripSaveFlag = 1;
	else			gTripSaveFlag = 0;

	TripInfoNow.CODE	= trip_code;
	TripInfoNow.DATA	= trip_data;
	strncpy( TripInfoNow.MSG,st,20) ;

	gMachineState 		= STATE_TRIP;
	TripInfoNow.CURRENT	= Is_mag_rms;
	TripInfoNow.VDC 	= Vdc;
//	TripInfoNow.HZ 		= Freq_out;
}	

int CheckOverCurrent( )
{
	static double OC_Timer = 0;

	if(( protect_reg.bit.OVER_I_ADC)&&( abs(giAdcUphase) > 4000)){
		trip_recording( ERR_OVER_CURRENT_U_PHASE, (double)(giAdcUphase),"I adc over U ph"); // I adc over U phase
		return ERR_OVER_CURRENT_U_PHASE;
	}
	
	if(( protect_reg.bit.OVER_I_ADC)&&( abs(giAdcUphase) < 100)){
		trip_recording( ERR_OVER_CURRENT_U_PHASE, (double)(giAdcUphase),"I adc under U_ph"); // I adc under U_phase
		return ERR_OVER_CURRENT_U_PHASE;
	}

	if(( protect_reg.bit.OVER_I_ADC)&&( abs(giAdcVphase) > 4000)){
		trip_recording( ERR_OVER_CURRENT_V_PHASE, (double)(giAdcVphase),"I adc over V_ph"); // I adc over V_phase
		return ERR_OVER_CURRENT_V_PHASE;
	}

	if(( protect_reg.bit.OVER_I_ADC)&&( abs(giAdcVphase) < 500)){
		trip_recording( ERR_OVER_CURRENT_V_PHASE, (double)(giAdcUphase),"I adc under V_ph"); // I adc under V_phase
		return ERR_OVER_CURRENT_V_PHASE;
	}

	// 소프트웨어 프로텍션 : 과전류 보호
	if( protect_reg.bit.OVER_I){
		if(Is_mag > OverCurLimit )	OC_Timer += Ts;
		else if(OC_Timer > Ts)		OC_Timer -= Ts;

		if (OC_Timer > over_I_time ){
			trip_recording( CODE_over_I_time,Is_mag,"OC Time out");
			return	CODE_over_I_time;
		}
	} 
	return 	0; 
}

//-----------------------------------------------
//  과전압 저전압 보호 
//-----------------------------------------------

int CheckOverVolt( )
{
	static int OverVoltCount = 0;

	if( protect_reg.bit.OVER_VOLT == 0 ) return 0;

	if (Vdc > over_volt_set ) OverVoltCount++;
	else if( OverVoltCount > 0) OverVoltCount --;

	if (OverVoltCount > 5 )
	{
		OverVoltCount = 6;
		trip_recording( CODE_over_current_level,Vdc,"Trip Over Volt");

		return CODE_over_current_level;
	}
	return 0;
}

//-----------------------------------------------
//  저전압 보호 
//-----------------------------------------------

int CheckUndeVolt( )
{
	static int UnderVoltCount = 0;

	if( protect_reg.bit.UNVER_VOLT == 0 ) return 0;

	if (Vdc < under_volt_set) 	UnderVoltCount++;
	else if( UnderVoltCount > 0) 	UnderVoltCount--;

	if (UnderVoltCount > 5 )
	{
		UnderVoltCount = 6;
		trip_recording( CODE_under_volt_set,Vdc,"Trip Under Volt");

		return CODE_under_volt_set;
	}
	return 0;
}

int CheckIGBTFault( )
{
	unsigned int xbus_in, temp,temp2;
//	static int trip_count=0;

	if( protect_reg.bit.IGBT_FAULT == 0 ) return 0;

	xbus_in = ZONE0_BUF[0x0050];   // debug

	temp = (xbus_in | 0xc0ff);

	temp2 = temp & 0x0100;
	if( temp2 == 0 ){
		trip_recording( ERR_IGBT_W,Is_abc[as],"ERR_IGBT_W"); 
		return ERR_IGBT_W;
	}
	temp2 = temp & 0x0200;
	if( temp2 == 0 ){
		trip_recording( ERR_IGBT_U,Is_abc[as],"ERR_IGBT_U"); 
		return ERR_IGBT_U;
	}
	temp2 = temp & 0x0400;
	if( temp2 == 0 ){
		trip_recording( ERR_IGBT_V,Is_abc[as],"ERR_IGBT_V"); 
		return ERR_IGBT_V;
	}

	return 0;
}


// 8  0000 0001 0000 0000    U
// 9  0000 0010 0000 0000    V
// 10 0000 0100 0000 0000    W
// 11 0000 1000 0000 0000    R
// 12 0001 0000 0000 0000    S
// 13 0010 0000 0000 0000    T

int CheckIGBTFault2( )
{
	unsigned int xbus_in, temp,temp2;
//	static int trip_count=0;

	if( protect_reg.bit.IGBT_FAULT == 0 ) return 0;

	xbus_in = ZONE0_BUF[0x0050];   // debug

	temp = (xbus_in | 0xc7ff);

	temp2 = temp & 0x0800;
	if( temp2 == 0 ){
		trip_recording( ERR_IGBT_W,Is_abc[as],"ERR_IGBT_R"); 
		return ERR_IGBT_R;
	}
	temp2 = temp & 0x1000;
	if( temp2 == 0 ){
		trip_recording( ERR_IGBT_U,Is_abc[as],"ERR_IGBT_S"); 
		return ERR_IGBT_S;
	}
	temp2 = temp & 0x2000;
	if( temp2 == 0 ){
		trip_recording( ERR_IGBT_V,Is_abc[as],"ERR_IGBT_T"); 
		return ERR_IGBT_T;
	}

	return 0;
}

int CheckOverHeat( )
{
	static int OverHeatCount = 0;

	if( protect_reg.bit.OVER_HEAT == 0 ) return 0;


//	if( OVER_HEAT )					OverHeatCount ++;
//	else if( OverHeatCount > 0) 	OverHeatCount--;

	if( OverHeatCount > 10 )	// debug// Low --> High
	{
		OverHeatCount = 11;
		trip_recording( ERR_OVER_HEAT,Is_mag_rms,"TRIP Over Heat");
		return ERR_OVER_HEAT;
	}
	return 0 ;
}

//-----------------------------------------------
//
//  보호 기능 
//		매 스위칭 마다 이를 검토 한다. 
//----------------------------------------------
int trip_check()
{
	int TripCode;

	TripCode = 0;

	if( ( TripCode = CheckOverCurrent()) != 0 ) return TripCode ;	// debug
	if( ( TripCode = CheckOverVolt()   ) != 0 ) return TripCode ;
	if( ( TripCode = CheckUndeVolt()   ) != 0 ) return TripCode ;	// 최종적으로 점검을 한다. 
	if( ( TripCode = CheckOverHeat()   ) != 0 ) return TripCode ;
	if( ( TripCode = CheckIGBTFault()  ) != 0 ) return TripCode ;
	if( ( TripCode = CheckIGBTFault2() ) != 0 ) return TripCode ;
	return TripCode;
}

//-----------------------------------
// 트립 발생 릴레이를 On 하고 
// Reset를 기다린다. 
//-----------------------------------
// Trip Message는 트립이 발생된 순간에 저장을 한다. 
//

void TripProc( )
{
	int iCommand;
	int LoopCtrl;
	int temp;
	double fReference;
	double dbtemp;
	char str[30];

	str[29] = 0;
	EALLOW;
	GpioCtrlRegs.GPAMUX1.bit.GPIO0 	= 0;  // GPIO0 = PWM1A
	GpioCtrlRegs.GPAMUX1.bit.GPIO1 	= 0;  // GPIO1 = PWM1B
	GpioCtrlRegs.GPAMUX1.bit.GPIO2 	= 0;  // GPIO2 = PWM2A
	GpioCtrlRegs.GPAMUX1.bit.GPIO3 	= 0;  // GPIO3 = PWM2B
	GpioCtrlRegs.GPAMUX1.bit.GPIO4 	= 0;  // GPIO4 = PWM3A
	GpioCtrlRegs.GPAMUX1.bit.GPIO5 	= 0;  // GPIO5 = PWM3B

	GpioCtrlRegs.GPAMUX1.bit.GPIO6 	= 0;  // GPIO4A
	GpioCtrlRegs.GPAMUX1.bit.GPIO7 	= 0;  // GPIO4B
	GpioCtrlRegs.GPAMUX1.bit.GPIO8 	= 0;  // GPIO5A
	GpioCtrlRegs.GPAMUX1.bit.GPIO9 	= 0;  // GPIO5B
	GpioCtrlRegs.GPAMUX1.bit.GPIO10	= 0;  // GPIO6A
	GpioCtrlRegs.GPAMUX1.bit.GPIO11	= 0;  // GPIO6B

	GpioCtrlRegs.GPADIR.bit.GPIO0 	= 1;  // GPIO0 = Output
	GpioCtrlRegs.GPADIR.bit.GPIO1 	= 1;  // GPIO1 = Output
	GpioCtrlRegs.GPADIR.bit.GPIO2 	= 1;  // GPIO2 = Output
	GpioCtrlRegs.GPADIR.bit.GPIO3 	= 1;  // GPIO3 = Output
	GpioCtrlRegs.GPADIR.bit.GPIO4 	= 1;  // GPIO4 = Output
	GpioCtrlRegs.GPADIR.bit.GPIO5 	= 1;  // GPIO5 = Output

	GpioCtrlRegs.GPADIR.bit.GPIO6 	= 1;  // GPIO4A
	GpioCtrlRegs.GPADIR.bit.GPIO7 	= 1;  // GPIO4B
	GpioCtrlRegs.GPADIR.bit.GPIO8 	= 1;  // GPIO5A
	GpioCtrlRegs.GPADIR.bit.GPIO9 	= 1;  // GPIO5B
	GpioCtrlRegs.GPADIR.bit.GPIO10 	= 1;  // GPIO6A
	GpioCtrlRegs.GPADIR.bit.GPIO11 	= 1;  // GPIO6B


	GpioDataRegs.GPACLEAR.bit.GPIO0 = 1;  // Set Output
	GpioDataRegs.GPACLEAR.bit.GPIO1 = 1;  // Set Output
	GpioDataRegs.GPACLEAR.bit.GPIO2 = 1;  // Set Output
	GpioDataRegs.GPACLEAR.bit.GPIO3 = 1;  // Set Output
	GpioDataRegs.GPACLEAR.bit.GPIO4 = 1;  // Set Output
	GpioDataRegs.GPACLEAR.bit.GPIO5 = 1;  // Set Output

	GpioDataRegs.GPACLEAR.bit.GPIO6 = 1;  // Set Output
	GpioDataRegs.GPACLEAR.bit.GPIO7 = 1;  // Set Output
	GpioDataRegs.GPACLEAR.bit.GPIO8 = 1;  // Set Output
	GpioDataRegs.GPACLEAR.bit.GPIO9 = 1;  // Set Output
	GpioDataRegs.GPACLEAR.bit.GPIO10 = 1;  // Set Output
	GpioDataRegs.GPACLEAR.bit.GPIO11 = 1;  // Set Output

	EDIS;

	gMachineState = STATE_TRIP;

	MAIN_CHARGE_OFF;					// Main Charge Relay Off
	init_charge_flag=0;
	INIT_CHARGE_CLEAR;
	TRIP_OUT_ON;
		
	GetTimeAndDateStr(str);
	strncpy( TripInfoNow.TIME,str,20);

//	SaveTripDataToEeprom();  debug_jsk

	load_scib_tx_mail_box("TRP"); delay_msecs(20);
	snprintf( str,4,"%03d:",TripInfoNow.CODE);
	load_scib_tx_mail_box(str); delay_msecs(20);

	load_scib_tx_mail_box(TripInfoNow.MSG); delay_msecs(20);

	load_scib_tx_mail_box( TripInfoNow.TIME) ; delay_msecs(20);

	dbtemp = TripInfoNow.HZ;
	temp = (int)(floor(dbtemp +0.5));				
	snprintf( str,10,"Fq=%3d[hz]",temp);	
	load_scib_tx_mail_box(str);	delay_msecs(20);

	dbtemp = TripInfoNow.VDC;
	temp = (int)(floor(dbtemp +0.5));
	snprintf( str,10," VDC =%4d",temp);	
	load_scib_tx_mail_box(str);	delay_msecs(20);

	dbtemp = TripInfoNow.CURRENT;
	temp = (int)(floor(dbtemp +0.5));
	snprintf( str,10,"I1  =%4d ",temp);	
	load_scib_tx_mail_box(str);	delay_msecs(20);

	dbtemp = TripInfoNow.DATA;
	temp = (int)(floor(dbtemp +0.5));
	snprintf( str,10," DATA=%4d",temp);
	load_scib_tx_mail_box(str);	delay_msecs(20);

	LoopCtrl = CMD_NULL;
	while( LoopCtrl != CMD_RESET)
	{
		get_command( & iCommand, & fReference);	// Command를 입력 받음 				
		if( iCommand == CMD_RESET) LoopCtrl = CMD_RESET;
		Nop();
	}

	delay_msecs(50);
	while( LoopCtrl == CMD_RESET)
	{
		get_command( & iCommand, & fReference);	// Command를 입력 받음 				
		if( iCommand == CMD_STOP) LoopCtrl = CMD_STOP;
		Nop();
	}

	for( ; ; ) // system reset 
	{
		gMachineState = STATE_TRIP;
		Nop();
		asm (" .ref _c_int00"); // ;Branch to start of boot.asm in RTS library
		asm (" LB _c_int00"); // ;Branch to start of boot.asm in RTS library
	}
}

void GetTripInfo(int Point,TRIP_INFO * TripData )
{
	int TripDataPoint;
	int TripBaseAddr;
	int iTemp;
	char str[30]={0};
	UNION32 u32data;

	strncpy(TripData->MSG ,NULL,41);
	strncpy(TripData->TIME ,NULL,31);

	if( Point == 0){

//		* TripData = &TripInfoNow;
		TripData->CURRENT 	= TripInfoNow.CURRENT;
		TripData->DATA 		= TripInfoNow.DATA;
		TripData->HZ 		= TripInfoNow.HZ;
		TripData->CODE 		= TripInfoNow.CODE;
		TripData->VDC 		= TripInfoNow.VDC;
		strncpy(TripData->MSG  ,TripInfoNow.MSG,20);
		strncpy(TripData->TIME ,TripInfoNow.TIME,20);
		return ;
	}

	I2CA_ReadData(ADDR_24LC32,EPROM_ADDR_TRIP_POINT,&TripDataPoint);

// erased  
	if( ( 1 > Point ) || ( Point > 10) || (TripDataPoint == 0x00ff))
	{
		TripData->CURRENT = 0.0;
		TripData->DATA = 0.0;
		TripData->HZ = 0.0;
		TripData->CODE = 0.0;
		TripData->VDC = 0.0;
		if( TripDataPoint == 0x00ff){
			strncpy(TripData->MSG  ," NO TRIP DATA       ",20);
			strncpy(TripData->TIME ,"2008:07:24  00:57:00",20);
		}
		else {
			strncpy(TripData->MSG  ," Invalid Trip Code  ",20);
			strncpy(TripData->TIME ,"2008:07:24  00:57:00",20);
		}
		return ;
	}

	if( (TripDataPoint<1)||(TripDataPoint>10)){
		I2CA_WriteData(ADDR_24LC32, EPROM_ADDR_TRIP_POINT,1);
		TripDataPoint = 1;
	}
	EepromSaveFlag = 1;
// 저장된 립 데이터를 구한다. 
	iTemp = TripDataPoint - Point + 1;		// iPoint = 1~10;

	if( iTemp <= 0 ) iTemp += 10;

	TripBaseAddr = TRIP_BACKUP_ADDR + iTemp * 100;

	// Code
	read_eprom_data( TripBaseAddr+ 0, & u32data);
		TripData->CODE =  u32data.dword;

	// Data
	read_eprom_data( TripBaseAddr+ 4, & u32data);
		TripData->CURRENT =  u32data.dword;

	// Current
	read_eprom_data( TripBaseAddr+ 8, & u32data);
	TripData->CURRENT =  u32data.dword;

	// HZ
	read_eprom_data( TripBaseAddr+ 12, & u32data);
	TripData->HZ =  u32data.dword;

	// VDC
	read_eprom_data( TripBaseAddr+16, & u32data);
	TripData->VDC =  u32data.dword;

	// Time
	ReadTripString( TripBaseAddr+20,str);
	strncpy(TripData->TIME,str,20);

	ReadTripString( TripBaseAddr+40,str);
	strncpy(TripData->MSG,str,20);

	EepromSaveFlag = 0;
}

void WriteTripString(int StartAddr, char * str)
{
	int i;
	int Addr;
	int string[21]={0};
	
	for(i=0;i<20;i++) string[i] = (int)(*(str ++));

	Addr = StartAddr;

	for(i=0;i<20;i++) I2CA_WriteData(ADDR_24LC32,Addr+i,string[i]);
}

void ReadTripString(int StartAddr, char * str)
{
	int i;
	int Addr;
	int iTemp;	
	char StrBuf[30];

	Addr = StartAddr;

	for(i=0;i<20;i++){
		I2CA_ReadData(ADDR_24LC32,Addr+i,&iTemp);
		StrBuf[i] = (char)(iTemp);
	}
	StrBuf[20] =0;
	strncpy(str,StrBuf,20);
}

void SaveTripDataToEeprom()
{
	int TripDataPoint,TripBaseAddr;
	char str[30];
	UNION32 u32data;

	I2CA_ReadData(ADDR_24LC32,EPROM_ADDR_TRIP_POINT,&TripDataPoint);

	if( TripDataPoint == 0x00FF) TripDataPoint = 1;
	else TripDataPoint ++;

	if( TripDataPoint > 10 ) TripDataPoint = 1;
	
	I2CA_WriteData(ADDR_24LC32, EPROM_ADDR_TRIP_POINT, TripDataPoint);			
	 
	TripBaseAddr = TRIP_BACKUP_ADDR + TripDataPoint * 100;

	EepromSaveFlag = 1;
// Code
	u32data.dword = TripInfoNow.CODE;
	write_code_2_eeprom( TripBaseAddr+ 0, u32data);

// Data
	u32data.dword = TripInfoNow.DATA;
	write_code_2_eeprom( TripBaseAddr+ 4, u32data);

// Current
	u32data.dword = TripInfoNow.CURRENT;
	write_code_2_eeprom( TripBaseAddr+ 8, u32data);

// HZ
	u32data.dword = TripInfoNow.HZ;
	write_code_2_eeprom( TripBaseAddr+ 12, u32data);

// VDC
	u32data.dword = TripInfoNow.VDC;
	write_code_2_eeprom( TripBaseAddr+16, u32data);

// Time
	strncpy(str,TripInfoNow.TIME,20);
	WriteTripString( TripBaseAddr+20,str);

// Msg
	strncpy(str,TripInfoNow.MSG,20);
	WriteTripString( TripBaseAddr+40,str);

	EepromSaveFlag = 0;
}

void ClearTripDataToEeprom()
{
	int TripBaseAddr = 0;
	int TripDataPoint;
	int TripPointCount;
	char str[30];
	UNION32 u32data;

	EepromSaveFlag = 1;

	u32data.dword = 0.0;

	load_scib_tx_mail_box("WAIT FOR CLEAR DATA!");

	for(TripPointCount = 1; TripPointCount <= 10; TripPointCount++)
	{
		I2CA_ReadData(ADDR_24LC32,EPROM_ADDR_TRIP_POINT,&TripDataPoint);

		if( TripDataPoint == 0x00FF) TripDataPoint = 1;
		else TripDataPoint ++;
		if( TripDataPoint > 10 ) TripDataPoint = 1;
	
		I2CA_WriteData(ADDR_24LC32, EPROM_ADDR_TRIP_POINT, TripDataPoint);
		TripBaseAddr = TRIP_BACKUP_ADDR + TripDataPoint * 100;
		write_code_2_eeprom( TripBaseAddr+ 0, u32data);
		write_code_2_eeprom( TripBaseAddr+ 4, u32data);
		write_code_2_eeprom( TripBaseAddr+ 8, u32data);
		write_code_2_eeprom( TripBaseAddr+ 12, u32data);
		write_code_2_eeprom( TripBaseAddr+16, u32data);
		strncpy(str,"2010:01:01  00:00:00",20);
		WriteTripString( TripBaseAddr+20,str);
		strncpy(str," NO TRIP DATA       ",20);
		WriteTripString( TripBaseAddr+40,str);
	}
	EepromSaveFlag = 0;
	load_scib_tx_mail_box("CLEAR COMPLETE !!   ");
}

//------------------------------
// End
//------------------------------

