//=======================================
//  ACIM_Main.c
//=======================================

#include	"header.h"
#include	"extern.h"
#include	"global.h"

#define TEST_MODE   0

#define	GLOBAL_Q	15

//--- for PWM
void ADC_SOC_CNF( );

extern volatile float *ADCDRV_1ch_CLA_Rlt0;
extern volatile float *ADCDRV_1ch_CLA_Rlt1;

#pragma CODE_SECTION(adc_isr, "ramfuncs");
#pragma CODE_SECTION(cla1_isr1, "ramfuncs");
#pragma CODE_SECTION(epwm1_isr, "ramfuncs");
#pragma CODE_SECTION(cpu_timer0_isr,"ramfuncs");

//#pragma CODE_SECTION(adc_isr, "Cla1Prog");


#pragma DATA_SECTION(AdcResult0,"Cla1ToCpuMsgRAM");
#pragma DATA_SECTION(AdcResult1,"Cla1ToCpuMsgRAM");

volatile float AdcResult0;
volatile float AdcResult1;

unsigned int led_state=0x0001;
unsigned int led_state_out;
int led_count = 0;
int timer_irq_on = 0;
int temp1,temp2;
int check=0;

void main(void)
{
	DINT;
	InitSysCtrl(); 	InitPieCtrl();
	IER = 0x0000; 	IFR = 0x0000;
	InitPieVectTable();

	initGpio( );

//	MemCopy(&RamfuncsLoadStart, &RamfuncsLoadEnd, &RamfuncsRunStart);
//	InitFlash();

	runtime_count = 0; 
	protect_reg.all = 0;
	MAIN_CHARGE_OFF;

	gMachineState = STATE_POWER_ON; 

	DINT;	IER = 0x0000; 	IFR = 0x0000;

	EALLOW;
	PieVectTable.CLA1_INT1 	= &cla1_isr1;
	PieVectTable.TINT0 		= &cpu_timer0_isr;
	PieVectTable.EPWM1_INT 	= &epwm1_isr;
	PieVectTable.ADCINT1 	= &adc_isr;	
	PieVectTable.SCIRXINTA = &sciaRxFifoIsr;
	PieVectTable.SCITXINTA = &sciaTxFifoIsr;
   	EDIS;


	EALLOW;
	SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 1;
	EDIS;

	EALLOW;
	Cla1Regs.MPISRCSEL1.bit.PERINT1SEL = CLA_INT1_EPWM1INT;	// ADCINT1 starts Task2
	Cla1Regs.MIER.all |= M_INT1;   							// Enable  Task 1
	asm("   RPT #3 || NOP"); 
	EDIS;

   InitCpuTimers();   // For this example, only initialize the Cpu Timers
   ConfigCpuTimer(&CpuTimer0, 60, 1000);	// 1kHz

   CpuTimer0Regs.TCR.all = 0x4001; // Use write-only instruction to set TSS bit = 0
	CLA_Init();

	PieCtrlRegs.PIEIER1.bit.INTx1 = 1;	// Enable ADCINT1
	PieCtrlRegs.PIEIER1.bit.INTx7 = 1;	// Enable TINT0 in the PIE: Group 1 interrupt 7
	PieCtrlRegs.PIEIER11.bit.INTx1 = 1; // Enable INT 11.1 in the PIE (CLA Task1)

	IER |= M_INT1;
	IER |= M_INT3;	// Enable CPU INT3 which is connected to EPWM1-3 INT:
	IER |= M_INT11;   // Enable CPU Interrupt 11

	InitEPwm_ACIM_Inverter();
	ADC_SOC_CNF( ); // InitAdc()
	scia_fifo_init();
	I2CA_Init();	// Initalize I2C serial eeprom and Real Time Clock;

	EINT;   // Enable Global interrupt INTM
	ERTM;   // Enable Global realtime interrupt DBGM

#if TEST_MODE == 1
	for( ; ; ){

	}
#endif
	check = check & 0x00FF;

	// gPWMTripCode = 0;		// ������ �ʱ�ȭ 
	i = load_code2ram();
	if( i !=0 ) trip_proc();

	VariInit();
	if(HardwareParameterVerification() !=0 ) trip_proc();


	Loop_cnt = 0;
	CLA_cnt = 0;
	Buffer_full = 0;

	code_protect_inhibit_on = 0;
	if( code_protect_inhibit_on == 1)
	{
		protect_reg.bit.UNVER_VOLT = 0;			// udd �߰� 
		protect_reg.bit.EX_TRIP = 0;
		protect_reg.bit.OVER_VOLT = 0;
		protect_reg.bit.OVER_I_ADC = 0;
		protect_reg.bit.IGBT_FAULT = 0;		
		protect_reg.bit.IGBT_FAULT2 = 0;		
		protect_reg.bit.OVER_I = 0;
		protect_reg.bit.CONV_ADC = 0;

	}
	else {
		protect_reg.bit.UNVER_VOLT = 1;			// udd �߰� 
		protect_reg.bit.EX_TRIP = 1;
		protect_reg.bit.OVER_VOLT = 1;
		protect_reg.bit.OVER_I_ADC = 1;
		protect_reg.bit.IGBT_FAULT = 1;		
		protect_reg.bit.OVER_I = 1;
		protect_reg.bit.CONV_ADC = 1;
	}

	I_SENS_ENABLE_SET;		// 
	IRS_EN_SET;
	MAIN_CHARGE_ON;
	delay_msecs(10);

	trip_code = 0;

	for( ; ; )
	{
		if( gPWMTripCode !=0 )	trip_proc();		
		gPWMTripCode = trip_check();
		if( gPWMTripCode !=0 )	trip_proc();		
		get_command( & gCommand, & ref_in0);
//		analog_out_proc( );
		monitor_proc();

		if(gCommand == CMD_START)	// if( cmd == CMD_START )
		{
			trip_code = 0;
			switch( code_motor_ctrl_mode ) // Control Method
			{
			case 0:	trip_code = vf_loop_control(ref_in0)		; break;
			case 1:	trip_code = vf_loop_control(ref_in0)		; break;		// 
			}
			if( trip_code !=0 )	trip_proc();		
		}
	}
}

void InitEPwm_ACIM_Inverter()
{  
	MAX_PWM_CNT = (Uint16)( ( F_OSC * DSP28_PLLCR / igbt_pwm_freq ) * 0.5 * 0.5 );
	EPwm1Regs.ETSEL.bit.INTEN = 0;    		        // Enable INT

	EPwm1Regs.TBPRD =  MAX_PWM_CNT;			// Set timer period
	EPwm1Regs.TBPHS.half.TBPHS = 0x0000;           	// Phase is 0
	EPwm1Regs.TBCTR = 0x0000;                      	// Clear counter

	// Setup TBCLK
	EPwm1Regs.TBCTL.bit.PHSDIR = TB_UP;				// Count up
	EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN;	// 
	EPwm1Regs.TBCTL.bit.PHSEN = TB_ENABLE;			// 2010.06.21
	EPwm1Regs.TBCTL.bit.HSPCLKDIV = 0;				// Clock ratio to SYSCLKOUT
	EPwm1Regs.TBCTL.bit.CLKDIV = 0;
	EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_CTR_ZERO;        	

	EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;		// Load registers every ZERO
	EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;
	EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO;
	EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;   

	EPwm1Regs.CMPA.half.CMPA = MAX_PWM_CNT;
   
	EPwm1Regs.AQCTLA.bit.CAU = AQ_SET;
	EPwm1Regs.AQCTLA.bit.CAD = AQ_CLEAR;
   
	EPwm1Regs.DBCTL.bit.OUT_MODE 	= DB_FULL_ENABLE;

	EPwm1Regs.DBCTL.bit.POLSEL 	= DB_ACTV_HIC;

	EPwm1Regs.DBCTL.bit.IN_MODE 	= DBA_ALL;
	EPwm1Regs.DBRED = DEAD_TIME_COUNT;					// debug set to 4usec
	EPwm1Regs.DBFED = DEAD_TIME_COUNT;

	// Set PWM2   
	EPwm2Regs.TBPRD =  MAX_PWM_CNT;				// Set timer period
	EPwm2Regs.TBCTL.bit.PHSDIR = TB_UP;	// Count up
	EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; 		// Count up
	EPwm2Regs.TBCTL.bit.HSPCLKDIV = 0;       			// Clock ratio to SYSCLKOUT
	EPwm2Regs.TBCTL.bit.CLKDIV = 0;          			// Slow just to observe on the scope

	EPwm2Regs.TBPHS.half.TBPHS = 0x0000;           	// Phase is 0
	EPwm2Regs.TBCTL.bit.PHSEN = TB_ENABLE; 
	EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN;        	
	EPwm2Regs.CMPA.half.CMPA = MAX_PWM_CNT;

	EPwm2Regs.AQCTLA.bit.CAU = AQ_SET;             		
	EPwm2Regs.AQCTLA.bit.CAD = AQ_CLEAR;

	EPwm2Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE;
	EPwm2Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC;		

	EPwm2Regs.DBCTL.bit.IN_MODE = DBA_ALL;
	EPwm2Regs.DBRED = DEAD_TIME_COUNT;
	EPwm2Regs.DBFED = DEAD_TIME_COUNT;
	EPwm2Regs.ETSEL.bit.INTEN = 0;                 	

//Set PWM3 
	EPwm3Regs.TBPRD =  MAX_PWM_CNT;			// Set timer period

	EPwm3Regs.TBCTL.bit.PHSDIR 		= TB_UP;				// Count up
	EPwm3Regs.TBCTL.bit.CTRMODE 	= TB_COUNT_UPDOWN; 	// Count up
	EPwm3Regs.TBCTL.bit.HSPCLKDIV 	= TB_DIV1;		// 
	EPwm3Regs.TBCTL.bit.CLKDIV 		= TB_DIV1;			// Slow so we can observe on the scope

	EPwm3Regs.TBPHS.half.TBPHS 		= 0x0000;           	// Phase is 0
	EPwm3Regs.TBCTL.bit.PHSEN 		= TB_ENABLE; 
	EPwm3Regs.TBCTL.bit.SYNCOSEL 	= TB_SYNC_IN;        	

	EPwm3Regs.CMPA.half.CMPA 		= MAX_PWM_CNT;

	EPwm3Regs.AQCTLA.bit.CAU 		= AQ_SET;	 
	EPwm3Regs.AQCTLA.bit.CAD 		= AQ_CLEAR;

	EPwm3Regs.DBCTL.bit.OUT_MODE 	= DB_FULL_ENABLE;
	EPwm3Regs.DBCTL.bit.POLSEL 		= DB_ACTV_HIC;

	EPwm3Regs.DBCTL.bit.IN_MODE 	= DBA_ALL;
	EPwm3Regs.DBRED 				= DEAD_TIME_COUNT;
	EPwm3Regs.DBFED 				= DEAD_TIME_COUNT;
	EPwm3Regs.ETSEL.bit.INTEN 		= 0;                  

	EPwm1Regs.ETPS.bit.INTPRD 	= 1;   // Generate interrupt on the 1st event
	EPwm1Regs.ETCLR.bit.INT 	= 1;   //  

	EPwm1Regs.ETSEL.bit.SOCAEN = 1;   // Enable SOC on A group
	EPwm1Regs.ETSEL.bit.SOCASEL = ET_CTR_PRD;//
	EPwm1Regs.ETSEL.bit.INTSEL 	= ET_CTR_ZERO;	// Select INT on Zero event 
	EPwm1Regs.ETPS.bit.SOCAPRD = 1;    // Generate pulse on 1st event 
 	EPwm1Regs.ETSEL.bit.INTEN = 1;     // Enable INT
    PieCtrlRegs.PIEIER3.bit.INTx1 = 1;
//	PieCtrlRegs.PIEIER3.all = M_INT1;	// ePWM
}

/*

//--- for scia testing 2013.05.30 
	for( ; ; ){		

		serial_com_proc( & scia_cmd, & scia_ref);
		delay_msecs(100);
	}

//--- I2C test proc 2013.0523
	for( i = 0 ; i < 20 ; i ++ ){
		I2CA_WriteData(ADDR_24LC32, i ,i+11);
		I2CA_ReadData(ADDR_24LC32,  i, & check);
		Nop();

	}
    for( ; ; ) Nop();
*/

// end of ACIM_Main.c
